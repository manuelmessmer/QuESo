//   ____        ______  _____
//  / __ \      |  ____|/ ____|
// | |  | |_   _| |__  | (___   ___
// | |  | | | | |  __|  \___ \ / _ \'
// | |__| | |_| | |____ ____) | (_) |
//  \___\_\\__,_|______|_____/ \___/
//         Quadrature for Embedded Solids
//
//  License:    BSD 4-Clause License
//              See: https://github.com/manuelmessmer/QuESo/blob/main/LICENSE
//
//  Authors:    Manuel Messmer

//// STL includes
#include <map>
//// Project includes
#include "queso/io/io_utilities.h"

namespace queso {

void IO::WriteMeshToSTL(const TriangleMeshInterface& rTriangleMesh,
                        const std::string& rFilename,
                        EncodingType Encoding){
    // Open file
    std::ofstream file(rFilename, (Encoding == EncodingType::binary)
        ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << ".\n";

    const uint32_t num_triangles = static_cast<uint32_t>(rTriangleMesh.NumOfTriangles());

    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::little);

        constexpr size_t header_size = 80;
        char header[header_size] = {};
        std::strncpy(header, "Binary STL generated by QuESo", header_size-1);
        binary_writer.WriteRaw(header, header_size);
        binary_writer.WriteValue(num_triangles);

        for(IndexType triangle_id = 0; triangle_id < num_triangles; ++triangle_id) {
            const auto& p1 = rTriangleMesh.P1(triangle_id);
            const auto& p2 = rTriangleMesh.P2(triangle_id);
            const auto& p3 = rTriangleMesh.P3(triangle_id);
            const auto& normal = rTriangleMesh.Normal(triangle_id);

            const float coords[12] = { static_cast<float>(normal[0]), static_cast<float>(normal[1]), static_cast<float>(normal[2]),
                                       static_cast<float>(p1[0]), static_cast<float>(p1[1]), static_cast<float>(p1[2]),
                                       static_cast<float>(p2[0]), static_cast<float>(p2[1]), static_cast<float>(p2[2]),
                                       static_cast<float>(p3[0]), static_cast<float>(p3[1]), static_cast<float>(p3[2]) };
            binary_writer.WriteArray(coords);

            uint16_t attribute_byte_count = 0;
            binary_writer.WriteValue(attribute_byte_count);
        }
    } else { // Ascii
        file << std::fixed << std::setprecision(6);
        file << "solid QuESoExport\n";
        for(std::uint32_t triangle_id = 0; triangle_id < num_triangles; ++triangle_id) {
            const auto& p1 = rTriangleMesh.P1(triangle_id);
            const auto& p2 = rTriangleMesh.P2(triangle_id);
            const auto& p3 = rTriangleMesh.P3(triangle_id);
            const auto& normal = rTriangleMesh.Normal(triangle_id);

            file << "facet normal " << normal[0] << ' ' << normal[1] << ' ' << normal[2] << "\nouter loop\n";
            file << "vertex " << p1[0] << ' ' << p1[1] << ' ' << p1[2] << '\n';
            file << "vertex " << p2[0] << ' ' << p2[1] << ' ' << p2[2] << '\n';
            file << "vertex " << p3[0] << ' ' << p3[1] << ' ' << p3[2] << '\n';
            file << "endloop\nendfacet\n";
        }
        file << "endsolid QuESoExport\n";
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write conditions to file: " << rFilename << ".\n";
}

void IO::WriteMeshToVTK(const TriangleMeshInterface& rTriangleMesh,
                        const std::string& rFilename,
                        EncodingType Encoding) {

    // Open file
    std::ofstream file(rFilename, (Encoding == EncodingType::binary)
        ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << ".\n";

    const SizeType num_elements = rTriangleMesh.NumOfTriangles();
    const SizeType num_points = rTriangleMesh.NumOfVertices();


    // Header
    file << "# vtk DataFile Version 4.1\n";
    file << "vtk output\n";
    file << ((Encoding == EncodingType::binary) ? "BINARY\n" : "ASCII\n");
    file << "DATASET UNSTRUCTURED_GRID\n";

    if(Encoding == EncodingType::ascii) {
        file << std::fixed << std::setprecision(15);
    }

    file << "POINTS " << num_points << " double\n";

    const auto& r_vertices = rTriangleMesh.GetVertices();
    if(Encoding == EncodingType::binary){
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for(const auto& r_vertice : r_vertices) {
            binary_writer.WriteValue(r_vertice[0]);
            binary_writer.WriteValue(r_vertice[1]);
            binary_writer.WriteValue(r_vertice[2]);
        }
    } else { // ascii
        for(const auto& r_vertice : r_vertices) {
            file << r_vertice[0] << ' ' << r_vertice[1] << ' ' << r_vertice[2] << '\n';
        }
    }

    // Write Cells
    file << "CELLS " << num_elements << " " << num_elements*4 << '\n';
    if(Encoding == EncodingType::binary){
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for(IndexType i = 0; i < num_elements; ++i) {
            std::uint32_t count = 3;
            binary_writer.WriteValue(count);
            for( auto id : rTriangleMesh.VertexIds(i) ){
                std::uint32_t index = static_cast<std::uint32_t>(id);
                binary_writer.WriteValue(index);
            }
        }
    } else { // ascii
        for(IndexType i = 0; i < num_elements; ++i) {
            file << 3;
            for( auto id : rTriangleMesh.VertexIds(i) ){
                file << ' ' << id;
            }
            file << '\n';
        }
    }

    file << "CELL_TYPES " << num_elements << '\n';
    if(Encoding == EncodingType::binary){
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for( IndexType i = 0; i < num_elements; ++i){
            std::uint32_t value = 5;
            binary_writer.WriteValue(value);
        }
    } else { // ascii
        for( IndexType i = 0; i < num_elements; ++i){
            file << 5 << '\n';
        }
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write mesh to file: " << rFilename << ".\n";
}

void IO::ReadMeshFromSTL(TriangleMeshInterface& rTriangleMesh,
                         const std::string& rFilename){

    // Open file
    if( GetEncodingType(rFilename) == EncodingType::ascii ) {
        return ReadMeshFromSTL_Ascii(rTriangleMesh, rFilename);
    } else {
        return ReadMeshFromSTL_Binary(rTriangleMesh, rFilename);
    }
}



////// Private member functions //////

IO::EncodingType IO::GetEncodingType(const std::string& rFilename) {
    std::ifstream file(rFilename, std::ios::in | std::ios::binary);
    QuESo_ERROR_IF(!file) << "Could not open file: " << rFilename << std::endl;

    std::string firstLine;
    std::getline(file, firstLine);

    // Check if file starts with "solid".
    if (firstLine.find("solid") != 0) {
        // Ascii must start with solid, binary can start with solid.
        return EncodingType::binary;
    }

    // Check for Ascii-specific keywords in the next 20 lines.
    std::string line;
    int lineCount = 0;
    while (std::getline(file, line) && lineCount++ < 20) {
        if (line.find("facet normal") != std::string::npos ||
            line.find("outer loop") != std::string::npos ||
            line.find("normal") != std::string::npos ||
            line.find("facet") != std::string::npos )  {
            return EncodingType::ascii;
        }
    }

    // If "solid" was found but no Ascii markers, check for non-printable characters.
    file.clear();
    file.seekg(0, std::ios::beg);
    char buffer[512];
    file.read(buffer, sizeof(buffer));
    std::streamsize bytes_read = file.gcount();
    for (std::streamsize i = 0; i < bytes_read; ++i) {
        if (buffer[i] == '\0') {
            return EncodingType::binary;;
        }
    }

    return EncodingType::ascii; // Likely Ascii
}

void IO::ReadMeshFromSTL_Ascii(TriangleMeshInterface& rTriangleMesh,
                               const std::string& rFilename){
    // Open file
    std::ifstream file(rFilename);
    QuESo_ERROR_IF(!file) << "Could not open file: " << rFilename << std::endl;

    // Initialize map
    IndexType index = 0;
    std::map<Vector3d, IndexType, PointComparison> index_map;

    rTriangleMesh.Clear();
    rTriangleMesh.Reserve(10000);

    std::string line;

    // Skip lines until we hit the first "facet"
    while (std::getline(file, line)) {
        if (line.find("facet") != std::string::npos) {
            break; // We've found the start of the actual STL data
        }
    }
    do {
        if (line.find("endsolid") != std::string::npos) {
            break;
        }
        if (line.find("facet") != std::string::npos) {
            std::getline(file, line); // Expect "outer loop"
            if (!file.good() || line.find("outer loop") == std::string::npos) {
                QuESo_ERROR << "Expected 'outer loop' but got: " << line << std::endl;
            }

            Vector3i triangle{};
            std::array<PointType, 3> vertices;

            for (int i = 0; i < 3; ++i) {
                if(!std::getline(file, line)) {
                    QuESo_ERROR << "Unexpected EOF reading vertex" << std::endl;
                }
                std::istringstream iss(line);
                std::string word;
                iss >> word; // "vertex"
                float xf, yf, zf;
                iss >> xf >> yf >> zf;
                PointType vertex = PointType{static_cast<double>(xf),
                                             static_cast<double>(yf),
                                             static_cast<double>(zf)};

                // Map is used to ensure unique vertices. Note that STL does not reuse vertices.
                auto [it, inserted] = index_map.try_emplace(vertex, 0);
                if(inserted) {
                    triangle[i] = index;
                    it->second = index++;
                    rTriangleMesh.AddVertex(vertex);
                    vertices[i] = vertex;
                }
                else {
                    triangle[i] = it->second;
                    vertices[i] = it->first;
                }
            }
            // Add Triangle
            rTriangleMesh.AddTriangle(triangle);

            // Note: STL are often given in single precision. Therefore, we compute the normals based on
            // the given vertices, which are now in double precision.
            const PointType normal = TriangleMeshInterface::Normal(vertices[0], vertices[1], vertices[2]);
            rTriangleMesh.AddNormal( normal );

            std::getline(file, line); // endloop
            if (!file.good() || line.find("endloop") == std::string::npos) {
                QuESo_ERROR << "Expected 'endloop' but got: " << line << std::endl;
            }
            std::getline(file, line); // endfacet
            if (!file.good() || line.find("endfacet") == std::string::npos) {
                QuESo_ERROR << "Expected 'endfacet' but got: " << line << std::endl;
            }
        }
    } while (std::getline(file, line));

    rTriangleMesh.Check();
}

void IO::ReadMeshFromSTL_Binary(TriangleMeshInterface& rTriangleMesh,
                                const std::string& rFilename){

    // Open file
    std::ifstream file(rFilename, std::ios::binary);
    QuESo_ERROR_IF(!file) << "Could not open file: " << rFilename << std::endl;

    // Read header
    char header[80];
    file.read(header, 80);
    if (!file.good()) {
        QuESo_ERROR << "File " << rFilename << " is empty or corrupted.\n";
    }

    // Initialize map
    IndexType index = 0;
    std::map<Vector3d, IndexType, PointComparison> index_map;

    // Read number of triangles
    std::uint32_t num_triangles;
    if(!(file.read(reinterpret_cast<char*>(&num_triangles), sizeof(num_triangles)))) {
        QuESo_ERROR << "Couldnt read number of triangles. \n";
    }
    rTriangleMesh.Clear();
    rTriangleMesh.Reserve(static_cast<IndexType>(num_triangles));

    // Loop over all triangles
    for(IndexType i=0; i<static_cast<IndexType>(num_triangles); ++i) {
        { // Read and ignore normals
            float normal[3];
            file.read(reinterpret_cast<char*>(normal), sizeof(normal));
            QuESo_ERROR_IF(!file) << "Couldn't read triangle normal.\n";
        }

        // Read triangles and vertices. Each vertex is read seperately.
        Vector3i triangle{};
        std::array<PointType, 3> vertices;
        for(int j=0; j<3; ++j) {
            float coords[3];
            file.read(reinterpret_cast<char*>(coords), sizeof(coords));
            QuESo_ERROR_IF(!file) << "Couldn't read triangle vertex.\n";

            Vector3d vertex = {static_cast<double>(coords[0]),
                               static_cast<double>(coords[1]),
                               static_cast<double>(coords[2])};

            // Map is used to ensure unique vertices. Note that STL does not reuse vertices.
            auto [it, inserted] = index_map.try_emplace(vertex, 0);
            if(inserted) {
                triangle[j] = index;
                it->second = index++;
                rTriangleMesh.AddVertex(vertex);
                vertices[j] = vertex;
            }
            else {
                triangle[j] = it->second;
                vertices[j] = it->first;
            }
        }

        // Add triangle
        rTriangleMesh.AddTriangle(triangle);

        // Note: STL are often given in single precision. Therefore, we compute the normals based on
        // the given vertices, which are now in double precision.
        const PointType normal = TriangleMeshInterface::Normal(vertices[0], vertices[1], vertices[2]);
        rTriangleMesh.AddNormal(normal);

        // Read so-called attribute byte count and ignore it
        std::uint16_t attribute_byte_count;
        file.read(reinterpret_cast<char*>(&attribute_byte_count), sizeof(attribute_byte_count));
        QuESo_ERROR_IF(!file) << "Couldn't read attribute byte count.\n";
    }

    rTriangleMesh.Check();
}


} // End namespace queso


