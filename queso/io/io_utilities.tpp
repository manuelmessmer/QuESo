//   ____        ______  _____
//  / __ \      |  ____|/ ____|
// | |  | |_   _| |__  | (___   ___
// | |  | | | | |  __|  \___ \ / _ \'
// | |__| | |_| | |____ ____) | (_) |
//  \___\_\\__,_|______|_____/ \___/
//         Quadrature for Embedded Solids
//
//  License:    BSD 4-Clause License
//              See: https://github.com/manuelmessmer/QuESo/blob/main/LICENSE
//
//  Authors:    Manuel Messmer

/// STL includes
#include <cstring>

namespace queso {

template<typename TDictType>
void IO::WriteDictionaryToJSON(const TDictType& rDictionary, const std::string& rFilename) {
    std::ofstream file(rFilename, std::ios::out);
    QuESo_ERROR_IF(!file) << "Warning :: Could not create/open file: " << rFilename << ".\n";

    file << rDictionary;

    QuESo_ERROR_IF(!file.good()) << "Warning :: Failed to write Dictionary to file: " << rFilename << ".\n";
}

template<typename TElementType>
void IO::WriteConditionToSTL(const Condition<TElementType>& rCondition,
                             const std::string& rFilename,
                             bool Binary) {

    std::ofstream file(rFilename, Binary ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Warning :: Could not create/open file: " << rFilename << ".\n";

    uint32_t num_triangles = std::accumulate(rCondition.SegmentsBegin(), rCondition.SegmentsEnd(),
        uint32_t{0}, [](uint32_t Acc, const auto& rSegment) {
            return Acc + static_cast<uint32_t>(rSegment.GetTriangleMesh().NumOfTriangles()); });

    if(Binary) {
        constexpr size_t header_size = 80;
        char header[header_size] = {};
        std::strncpy(header, "Binary STL generated by QuESo", header_size-1);
        file.write(header, header_size);
        file.write(reinterpret_cast<const char*>(&num_triangles), sizeof(num_triangles));

        for( const auto& r_segments : rCondition.Segments() ){
            const auto& r_triangle_mesh = r_segments.GetTriangleMesh();
            const IndexType local_num_triangles = r_triangle_mesh.NumOfTriangles();
            for(IndexType triangle_id = 0; triangle_id < local_num_triangles; ++triangle_id) {
                const auto& p1 = r_triangle_mesh.P1(triangle_id);
                const auto& p2 = r_triangle_mesh.P2(triangle_id);
                const auto& p3 = r_triangle_mesh.P3(triangle_id);
                const auto& normal = r_triangle_mesh.Normal(triangle_id);

                const float coords[12] = { static_cast<float>(normal[0]), static_cast<float>(normal[1]), static_cast<float>(normal[2]),
                                           static_cast<float>(p1[0]), static_cast<float>(p1[1]), static_cast<float>(p1[2]),
                                           static_cast<float>(p2[0]), static_cast<float>(p2[1]), static_cast<float>(p2[2]),
                                           static_cast<float>(p3[0]), static_cast<float>(p3[1]), static_cast<float>(p3[2]) };

                file.write(reinterpret_cast<const char*>(coords), sizeof(coords));
                uint16_t attribute_byte_count = 0;
                file.write(reinterpret_cast<const char*>(&attribute_byte_count), sizeof(attribute_byte_count));
            }
        }
    }
    else { // Ascii export
        file << std::fixed << std::setprecision(6);
        file << "solid QuESoExport\n";
        for(const auto& r_segments : rCondition.Segments()) {
            const auto& r_triangle_mesh = r_segments.GetTriangleMesh();
            const IndexType local_num_triangles = r_triangle_mesh.NumOfTriangles();

            for(IndexType triangle_id = 0; triangle_id < local_num_triangles; ++triangle_id) {
                const auto& p1 = r_triangle_mesh.P1(triangle_id);
                const auto& p2 = r_triangle_mesh.P2(triangle_id);
                const auto& p3 = r_triangle_mesh.P3(triangle_id);
                const auto& normal = r_triangle_mesh.Normal(triangle_id);

                file << "facet normal " << normal[0] << ' ' << normal[1] << ' ' << normal[2] << "\nouter loop\n";
                file << "vertex " << p1[0] << ' ' << p1[1] << ' ' << p1[2] << '\n';
                file << "vertex " << p2[0] << ' ' << p2[1] << ' ' << p2[2] << '\n';
                file << "vertex " << p3[0] << ' ' << p3[1] << ' ' << p3[2] << '\n';
                file << "endloop\nendfacet\n";
            }
        }
        file << "endsolid QuESoExport\n";
    }

    QuESo_ERROR_IF(!file.good()) << "Warning :: Failed to write conditions to file: " << rFilename << ".\n";
}


template<typename TElementType>
void IO::WriteElementsToVTK(const BackgroundGrid<TElementType>& rBackgroundGrid,
                            const std::string& rFilename,
                            bool Binary) {
    const SizeType num_elements = rBackgroundGrid.NumberOfActiveElements();

    std::ofstream file;
    if(Binary)
        file.open(rFilename, std::ios::out | std::ios::binary);
    else
        file.open(rFilename);

    QuESo_ERROR_IF( !file.is_open() ) << "Could not open file: " << rFilename << ".\n";

    file << "# vtk DataFile Version 4.1" << std::endl;
    file << "vtk output" << std::endl;
    if(Binary)
        file << "BINARY"<< std::endl;
    else
        file << "ASCII"<< std::endl;

    file << "DATASET UNSTRUCTURED_GRID" << std::endl;
    file << "POINTS " << num_elements*8 << " double" << std::endl;

    const auto begin_el_itr = rBackgroundGrid.ElementsBegin();
    for( IndexType i = 0; i < num_elements; ++i){
        const auto el_itr = (begin_el_itr + i);
        const auto& lower_point = el_itr->GetBoundsXYZ().first;
        const auto& upper_point = el_itr->GetBoundsXYZ().second;

        if( Binary ){
            double rx0 = lower_point[0];
            SwapEnd(rx0);
            double rx1 = upper_point[0];
            SwapEnd(rx1);
            double ry0 = lower_point[1];
            SwapEnd(ry0);
            double ry1 = upper_point[1];
            SwapEnd(ry1);
            double rz0 = lower_point[2];
            SwapEnd(rz0);
            double rz1 = upper_point[2];
            SwapEnd(rz1);

            file.write(reinterpret_cast<char*>(&rx0), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry0), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz0), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx1), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry0), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz0), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx1), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry1), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz0), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx0), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry1), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz0), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx0), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry0), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz1), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx1), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry0), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz1), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx1), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry1), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz1), sizeof(double));

            file.write(reinterpret_cast<char*>(&rx0), sizeof(double));
            file.write(reinterpret_cast<char*>(&ry1), sizeof(double));
            file.write(reinterpret_cast<char*>(&rz1), sizeof(double));
        }
        else {
            file << lower_point[0] << ' ' << lower_point[1] << ' ' << lower_point[2] << std::endl;
            file << upper_point[0] << ' ' << lower_point[1] << ' ' << lower_point[2] << std::endl;
            file << upper_point[0] << ' ' << upper_point[1] << ' ' << lower_point[2] << std::endl;
            file << lower_point[0] << ' ' << upper_point[1] << ' ' << lower_point[2] << std::endl;
            file << lower_point[0] << ' ' << lower_point[1] << ' ' << upper_point[2] << std::endl;
            file << upper_point[0] << ' ' << lower_point[1] << ' ' << upper_point[2] << std::endl;
            file << upper_point[0] << ' ' << upper_point[1] << ' ' << upper_point[2] << std::endl;
            file << lower_point[0] << ' ' << upper_point[1] << ' ' << upper_point[2] << std::endl;
        }
    }
    file << std::endl;
    // Write Cells
    file << "Cells " << num_elements << " " << num_elements*9 << std::endl;
    for( int i = 0; i < static_cast<int>(rBackgroundGrid.NumberOfActiveElements()); ++i){
        if( Binary ){
            int k = 8;
            WriteBinary(file, k);
        for( int j = 0; j < 8; ++j){
            k = 8*i+j;
            WriteBinary(file, k);
        }
        }
        else {
            file << 8 << ' ' << 8*i     << ' ' << 8*i + 1 << ' ' << 8*i + 2 << ' ' << 8*i + 3
                        << ' ' << 8*i + 4 << ' ' << 8*i + 5 << ' ' << 8*i + 6 << ' ' << 8*i + 7 << std::endl;
        }
    }
    file << std::endl;

    file << "CELL_TYPES " << rBackgroundGrid.NumberOfActiveElements() << std::endl;
    for( int i = 0; i < static_cast<int>(rBackgroundGrid.NumberOfActiveElements()); ++i){
        if( Binary ){
            int k = 12;
            WriteBinary(file, k);
        }
        else {
            file << 12 << std::endl;
        }
    }
    file << std::endl;
    file.close();
}

template<typename TElementType>
void IO::WritePointsToVTK(const BackgroundGrid<TElementType>& rBackgroundGrid,
                            const std::string& rFilename,
                            bool Binary) {

    const IndexType num_points = std::accumulate(
        rBackgroundGrid.ElementsBegin(), rBackgroundGrid.ElementsEnd(), IndexType{0}, [](IndexType Acc, const auto& rElement) {
            return Acc + rElement.GetIntegrationPoints().size(); } );
    const IndexType num_elements = num_points;

    std::ofstream file;
    if(Binary)
        file.open(rFilename, std::ios::out | std::ios::binary);
    else
        file.open(rFilename);

    QuESo_ERROR_IF( !file.is_open() ) << "Could not open file: " << rFilename << ".\n";

    file << "# vtk DataFile Version 4.1" << std::endl;
    file << "vtk output" << std::endl;
    if(Binary)
        file << "BINARY"<< std::endl;
    else
        file << "ASCII"<< std::endl;


    file << "DATASET UNSTRUCTURED_GRID" << std::endl;
    file << "POINTS " << num_points << " double" << std::endl;

    const auto el_it_ptr_begin = rBackgroundGrid.ElementsBegin();
    for( IndexType i = 0; i < rBackgroundGrid.NumberOfActiveElements(); ++i){
        const auto el_ptr = (el_it_ptr_begin + i);
        const auto& r_points = el_ptr->GetIntegrationPoints();
        for( const auto& r_point : r_points ){
            auto point_global = el_ptr->PointFromParamToGlobal(r_point.data());

            if( Binary ){
                WriteBinary(file, point_global[0]);
                WriteBinary(file, point_global[1]);
                WriteBinary(file, point_global[2]);
            }
            else {
                file << point_global[0] << ' ' << point_global[1] << ' ' << point_global[2] << std::endl;
            }
        }

    }
    file << std::endl;

    // Write Cells
    file << "Cells " << num_elements << " " << num_elements*2 << std::endl;
    for( IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            int k = 1;
            WriteBinary(file, k);
            k = i;
            WriteBinary(file, k);
        }
        else {
            file << 1 << ' ' << i << std::endl;
        }
    }
    file << std::endl;

    file << "CELL_TYPES " << num_elements << std::endl;
    for( IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            int k = 1;
            WriteBinary(file, k);
        }
        else {
            file << 1 << std::endl;
        }
    }
    file << std::endl;

    file << "POINT_DATA " << num_points << std::endl;
    file << "SCALARS Weights double 1" << std::endl;
    file << "LOOKUP_TABLE default" << std::endl;
    for( IndexType i = 0; i < rBackgroundGrid.NumberOfActiveElements(); ++i){
        const auto el_ptr = (el_it_ptr_begin + i);
        const auto& points = el_ptr->GetIntegrationPoints();
        for( const auto& point : points ){
            if( Binary ){
                double rw = point.Weight();
                WriteBinary(file, rw);
            }
            else {
                file << point.Weight() << std::endl;
            }
        }
    }
    file << std::endl;
    file.close();
}

template<typename Type>
void IO::WritePointsToVTK(const std::vector<Type>& rPoints,
                            const std::string& rFilename,
                            bool Binary) {

    const auto begin_points_it_ptr = rPoints.begin();
    const IndexType num_points = rPoints.size();
    const IndexType num_elements = rPoints.size();

    std::ofstream file;
    if(Binary)
        file.open(rFilename, std::ios::out | std::ios::binary);
    else
        file.open(rFilename);

    QuESo_ERROR_IF( !file.is_open() ) << "Could not open file: " << rFilename << ".\n";

    file << "# vtk DataFile Version 4.1" << std::endl;
    file << "vtk output" << std::endl;
    if(Binary)
        file << "BINARY"<< std::endl;
    else
        file << "ASCII"<< std::endl;

    file << "DATASET UNSTRUCTURED_GRID" << std::endl;
    file << "POINTS " << num_points << " double" << std::endl;

    for(IndexType i = 0; i < num_points; ++i){
        auto points_it = (begin_points_it_ptr + i);
        if( Binary ){
            // Make sure to create copy of points. "WriteBinary" will change them.
            auto p_x = (*points_it)[0];
            auto p_y = (*points_it)[1];
            auto p_z = (*points_it)[2];
            WriteBinary(file, p_x);
            WriteBinary(file, p_y);
            WriteBinary(file, p_z);
        }
        else {
            file << (*points_it)[0] << ' ' << (*points_it)[1] << ' ' << (*points_it)[2] << std::endl;
        }
    }
    file << std::endl;

    //Write Cells
    file << "Cells " << num_elements << " " << num_elements*2 << std::endl;
    for( IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            int k = 1;
            WriteBinary(file, k);
            k = i;
            WriteBinary(file, k);
        }
        else {
            file << 1 << ' ' << i << std::endl;
        }
    }
    file << std::endl;

    file << "CELL_TYPES " << num_elements << std::endl;
    for( IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            int k = 1;
            WriteBinary(file, k);
        }
        else {
        file << 1 << std::endl;
        }
    }
    file << std::endl;

    file << "POINT_DATA " << num_points << std::endl;
    file << "SCALARS Weights double 1" << std::endl;
    file << "LOOKUP_TABLE default" << std::endl;
    for(IndexType i = 0; i < num_points; ++i){
        auto points_it = (begin_points_it_ptr + i);

        if( Binary ){
            double rw = points_it->Weight();
            WriteBinary(file, rw);
        }
        else {
            file << points_it->Weight() << std::endl;
        }
    }
    file << std::endl;
    file.close();
}

} // End namespace queso