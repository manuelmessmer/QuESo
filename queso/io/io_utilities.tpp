//   ____        ______  _____
//  / __ \      |  ____|/ ____|
// | |  | |_   _| |__  | (___   ___
// | |  | | | | |  __|  \___ \ / _ \'
// | |__| | |_| | |____ ____) | (_) |
//  \___\_\\__,_|______|_____/ \___/
//         Quadrature for Embedded Solids
//
//  License:    BSD 4-Clause License
//              See: https://github.com/manuelmessmer/QuESo/blob/main/LICENSE
//
//  Authors:    Manuel Messmer

/// STL includes
#include <cstring>
#include <fstream>
#include <numeric>

/// Project includes
#include "queso/io/binary_buffer_writer.hpp"
#include "queso/includes/define.hpp"

namespace queso {

template<typename TDictType>
void IO::WriteDictionaryToJSON(const TDictType& rDictionary, const std::string& rFilename) {
    // Open file
    std::ofstream file(rFilename, std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << '.' << std::endl;

    file << rDictionary;

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write Dictionary to file: " << rFilename << '.' << std::endl;
}

template<typename TElementType>
void IO::WriteConditionToSTL(const Condition<TElementType>& rCondition,
                             const std::string& rFilename,
                             EncodingType Encoding) {
    // Open file
    std::ofstream file(rFilename, (Encoding==EncodingType::binary)
        ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << '.' << std::endl;

    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::little);

        const uint32_t num_triangles = std::accumulate(rCondition.SegmentsBegin(), rCondition.SegmentsEnd(),
            uint32_t{0}, [](uint32_t Acc, const auto& rSegment) {
                return Acc + static_cast<uint32_t>(rSegment.GetTriangleMesh().NumOfTriangles()); });

        constexpr IndexType header_size = 80;
        char header[header_size] = {};
        std::strncpy(header, "Binary STL generated by QuESo", header_size-1);
        binary_writer.WriteRaw(header, header_size);

        binary_writer.WriteValue(num_triangles);
        for(const auto& r_segments : rCondition.Segments()){
            const auto& r_triangle_mesh = r_segments.GetTriangleMesh();
            const IndexType local_num_triangles = r_triangle_mesh.NumOfTriangles();
            for(IndexType triangle_id = 0; triangle_id < local_num_triangles; ++triangle_id) {
                const auto& p1 = r_triangle_mesh.P1(triangle_id);
                const auto& p2 = r_triangle_mesh.P2(triangle_id);
                const auto& p3 = r_triangle_mesh.P3(triangle_id);
                const auto& normal = r_triangle_mesh.Normal(triangle_id);

                const float coords[12] = { static_cast<float>(normal[0]), static_cast<float>(normal[1]), static_cast<float>(normal[2]),
                                           static_cast<float>(p1[0]), static_cast<float>(p1[1]), static_cast<float>(p1[2]),
                                           static_cast<float>(p2[0]), static_cast<float>(p2[1]), static_cast<float>(p2[2]),
                                           static_cast<float>(p3[0]), static_cast<float>(p3[1]), static_cast<float>(p3[2]) };

                binary_writer.WriteArray<float, 12>(coords);

                std::uint16_t attribute_byte_count = 0;
                binary_writer.WriteValue(attribute_byte_count);
            }
        }
    } else { // ascii
        file << std::fixed << std::setprecision(6);
        file << "solid QuESoExport\n";
        for(const auto& r_segments : rCondition.Segments()) {
            const auto& r_triangle_mesh = r_segments.GetTriangleMesh();
            const IndexType local_num_triangles = r_triangle_mesh.NumOfTriangles();

            for(IndexType triangle_id = 0; triangle_id < local_num_triangles; ++triangle_id) {
                const auto& p1 = r_triangle_mesh.P1(triangle_id);
                const auto& p2 = r_triangle_mesh.P2(triangle_id);
                const auto& p3 = r_triangle_mesh.P3(triangle_id);
                const auto& normal = r_triangle_mesh.Normal(triangle_id);

                file << "facet normal " << normal[0] << ' ' << normal[1] << ' ' << normal[2] << "\nouter loop\n";
                file << "vertex " << p1[0] << ' ' << p1[1] << ' ' << p1[2] << '\n';
                file << "vertex " << p2[0] << ' ' << p2[1] << ' ' << p2[2] << '\n';
                file << "vertex " << p3[0] << ' ' << p3[1] << ' ' << p3[2] << '\n';
                file << "endloop\nendfacet\n";
            }
        }
        file << "endsolid QuESoExport\n";
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write conditions to file: " << rFilename << '.' << std::endl;
}


template<typename TElementType>
void IO::WriteElementsToVTK(const BackgroundGrid<TElementType>& rBackgroundGrid,
                            const std::string& rFilename,
                            EncodingType Encoding) {
    // Open file
    std::ofstream file(rFilename, (Encoding == EncodingType::binary)
        ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << '.' << std::endl;

    const SizeType num_elements = rBackgroundGrid.NumberOfActiveElements();

    // Header
    file << "# vtk DataFile Version 4.1\n";
    file << "vtk output\n";
    file << ((Encoding == EncodingType::binary) ? "BINARY\n" : "ASCII\n");
    file << "DATASET UNSTRUCTURED_GRID\n";

    if(Encoding == EncodingType::ascii) {
        file << std::fixed << std::setprecision(15);
    }

    // Write points
    file << "POINTS " << num_elements * 8 << " double\n";
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for (const auto& r_element : rBackgroundGrid.Elements()) {
            const auto& [lower_point, upper_point] = r_element.GetBoundsXYZ();
            auto vertices = GetHexahedronVertices(lower_point, upper_point);
            for (const auto& v : vertices) {
                binary_writer.WriteValue(v[0]);
                binary_writer.WriteValue(v[1]);
                binary_writer.WriteValue(v[2]);
            }
        }
    } else { // ascii
        for (const auto& r_element : rBackgroundGrid.Elements()) {
            const auto& [lower_point, upper_point] = r_element.GetBoundsXYZ();
            auto vertices = GetHexahedronVertices(lower_point, upper_point);
            for (const auto& v : vertices) {
                file << v[0] << ' ' << v[1] << ' ' << v[2] << '\n';
            }
        }
    }

    // Write cells
    file << "CELLS " << num_elements << " " << num_elements*9 << '\n';
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for (IndexType i = 0; i < num_elements; ++i) {
            std::uint32_t count = 8;
            binary_writer.WriteValue(count);
            for (std::uint32_t j = 0; j < 8; ++j) {
                std::uint32_t index = 8 * static_cast<std::uint32_t>(i) + j;
                binary_writer.WriteValue(index);
            }
        }
    } else { // ascii
        for (IndexType i = 0; i < num_elements; ++i) {
            file << 8;
            for (IndexType j = 0; j < 8; ++j) {
                file << ' ' << (8 * i + j);
            }
            file << '\n';
        }
    }

    // Write cell type
    file << "CELL_TYPES " << num_elements << '\n';
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        std::uint32_t value = 12;
        for (IndexType i = 0; i < num_elements; ++i) {
            binary_writer.WriteValue(value);
        }
    } else { // ascii
        for (IndexType i = 0; i < num_elements; ++i) {
            file << 12 << '\n';
        }
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write elements to file: " << rFilename << '.' << std::endl;
}

template<typename TElementType>
void IO::WritePointsToVTK(const BackgroundGrid<TElementType>& rBackgroundGrid,
                            const std::string& rFilename,
                            EncodingType Encoding) {
    // Open file
    std::ofstream file(rFilename, (Encoding == EncodingType::binary)
        ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << '.' << std::endl;

    const IndexType num_points = std::accumulate(
        rBackgroundGrid.ElementsBegin(), rBackgroundGrid.ElementsEnd(), IndexType{0},
        [](IndexType Acc, const auto& rElement) {
            return Acc + rElement.GetIntegrationPoints().size();
    });
    const IndexType num_elements = num_points;

    // Header
    file << "# vtk DataFile Version 4.1\n";
    file << "vtk output\n";
    file << ((Encoding == EncodingType::binary) ? "BINARY\n" : "ASCII\n");
    file << "DATASET UNSTRUCTURED_GRID\n";

    if(Encoding == EncodingType::ascii) {
        file << std::fixed << std::setprecision(15);
    }

    // Write points
    file << "POINTS " << num_points << " double\n";
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for(const auto& r_element : rBackgroundGrid.Elements()) {
            const auto& r_points = r_element.GetIntegrationPoints();
            for (const auto& r_point : r_points) {
                auto point_global = r_element.PointFromParamToGlobal(r_point.data());
                binary_writer.WriteValue(point_global[0]);
                binary_writer.WriteValue(point_global[1]);
                binary_writer.WriteValue(point_global[2]);
            }
        }
    } else { // ascii
        for(const auto& r_element : rBackgroundGrid.Elements()) {
            const auto& r_points = r_element.GetIntegrationPoints();
            for (const auto& r_point : r_points) {
                auto point_global = r_element.PointFromParamToGlobal(r_point.data());
                file << point_global[0] << ' ' << point_global[1] << ' ' << point_global[2] << '\n';
            }
        }
    }

    // Write Cells
    file << "CELLS " << num_elements << " " << num_elements*2 << '\n';
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for(IndexType i = 0; i < num_elements; ++i) {
            std::uint32_t k = 1;
            binary_writer.WriteValue(k);
            k = static_cast<std::uint32_t>(i);
            binary_writer.WriteValue(k);
        }
    } else { // ascii
        for(IndexType i = 0; i < num_elements; ++i) {
            file << 1 << ' ' << i << '\n';
        }
    }

    // Write cell types
    file << "CELL_TYPES " << num_elements << '\n';
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for(IndexType i = 0; i < num_elements; ++i) {
            std::uint32_t k = 1;
            binary_writer.WriteValue(k);
        }
    } else { // ascii
        for(IndexType i = 0; i < num_elements; ++i) {
            file << 1 << '\n';
        }
    }

    // Write weights
    file << "POINT_DATA " << num_points << '\n';
    file << "SCALARS Weights double 1\n";
    file << "LOOKUP_TABLE default\n";
    if(Encoding == EncodingType::binary) {
        BinaryBufferWriter binary_writer(file, BinaryBufferWriter::EndianType::big);
        for(const auto& r_element : rBackgroundGrid.Elements()){
            const auto& points = r_element.GetIntegrationPoints();
            for(const auto& point : points ){
                double weight = point.Weight();
                binary_writer.WriteValue(weight);
            }
        }
    } else { // ascii
        for(const auto& r_element : rBackgroundGrid.Elements()){
            const auto& points = r_element.GetIntegrationPoints();
            for(const auto& point : points ){
                file << point.Weight() << '\n';
            }
        }
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write points to file: " << rFilename << '.' << std::endl;
}

} // End namespace queso
