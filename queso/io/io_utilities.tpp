//   ____        ______  _____
//  / __ \      |  ____|/ ____|
// | |  | |_   _| |__  | (___   ___
// | |  | | | | |  __|  \___ \ / _ \'
// | |__| | |_| | |____ ____) | (_) |
//  \___\_\\__,_|______|_____/ \___/
//         Quadrature for Embedded Solids
//
//  License:    BSD 4-Clause License
//              See: https://github.com/manuelmessmer/QuESo/blob/main/LICENSE
//
//  Authors:    Manuel Messmer

/// STL includes
#include <cstring>

namespace queso {

template<typename TDictType>
void IO::WriteDictionaryToJSON(const TDictType& rDictionary, const std::string& rFilename) {
    // Open file
    std::ofstream file(rFilename, std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << ".\n";

    file << rDictionary;

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write Dictionary to file: " << rFilename << ".\n";
}

template<typename TElementType>
void IO::WriteConditionToSTL(const Condition<TElementType>& rCondition,
                             const std::string& rFilename,
                             bool Binary) {
    // Open file
    std::ofstream file(rFilename, Binary ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << ".\n";

    if(Binary) {
        const uint32_t num_triangles = std::accumulate(rCondition.SegmentsBegin(), rCondition.SegmentsEnd(),
            uint32_t{0}, [](uint32_t Acc, const auto& rSegment) {
                return Acc + static_cast<uint32_t>(rSegment.GetTriangleMesh().NumOfTriangles()); });

        constexpr size_t header_size = 80;
        char header[header_size] = {};
        std::strncpy(header, "Binary STL generated by QuESo", header_size-1);
        file.write(header, header_size);
        file.write(reinterpret_cast<const char*>(&num_triangles), sizeof(num_triangles));

        for(const auto& r_segments : rCondition.Segments()){
            const auto& r_triangle_mesh = r_segments.GetTriangleMesh();
            const IndexType local_num_triangles = r_triangle_mesh.NumOfTriangles();
            for(IndexType triangle_id = 0; triangle_id < local_num_triangles; ++triangle_id) {
                const auto& p1 = r_triangle_mesh.P1(triangle_id);
                const auto& p2 = r_triangle_mesh.P2(triangle_id);
                const auto& p3 = r_triangle_mesh.P3(triangle_id);
                const auto& normal = r_triangle_mesh.Normal(triangle_id);

                const float coords[12] = { static_cast<float>(normal[0]), static_cast<float>(normal[1]), static_cast<float>(normal[2]),
                                           static_cast<float>(p1[0]), static_cast<float>(p1[1]), static_cast<float>(p1[2]),
                                           static_cast<float>(p2[0]), static_cast<float>(p2[1]), static_cast<float>(p2[2]),
                                           static_cast<float>(p3[0]), static_cast<float>(p3[1]), static_cast<float>(p3[2]) };

                file.write(reinterpret_cast<const char*>(coords), sizeof(coords));
                uint16_t attribute_byte_count = 0;
                file.write(reinterpret_cast<const char*>(&attribute_byte_count), sizeof(attribute_byte_count));
            }
        }
    }
    else { // Ascii export
        file << std::fixed << std::setprecision(6);
        file << "solid QuESoExport\n";
        for(const auto& r_segments : rCondition.Segments()) {
            const auto& r_triangle_mesh = r_segments.GetTriangleMesh();
            const IndexType local_num_triangles = r_triangle_mesh.NumOfTriangles();

            for(IndexType triangle_id = 0; triangle_id < local_num_triangles; ++triangle_id) {
                const auto& p1 = r_triangle_mesh.P1(triangle_id);
                const auto& p2 = r_triangle_mesh.P2(triangle_id);
                const auto& p3 = r_triangle_mesh.P3(triangle_id);
                const auto& normal = r_triangle_mesh.Normal(triangle_id);

                file << "facet normal " << normal[0] << ' ' << normal[1] << ' ' << normal[2] << "\nouter loop\n";
                file << "vertex " << p1[0] << ' ' << p1[1] << ' ' << p1[2] << '\n';
                file << "vertex " << p2[0] << ' ' << p2[1] << ' ' << p2[2] << '\n';
                file << "vertex " << p3[0] << ' ' << p3[1] << ' ' << p3[2] << '\n';
                file << "endloop\nendfacet\n";
            }
        }
        file << "endsolid QuESoExport\n";
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write conditions to file: " << rFilename << ".\n";
}


template<typename TElementType>
void IO::WriteElementsToVTK(const BackgroundGrid<TElementType>& rBackgroundGrid,
                            const std::string& rFilename,
                            bool Binary) {
    // Open file
    std::ofstream file(rFilename, Binary ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << ".\n";

    const SizeType num_elements = rBackgroundGrid.NumberOfActiveElements();

    // Header
    file << "# vtk DataFile Version 4.1\n";
    file << "vtk output\n";
    file << (Binary ? "BINARY\n" : "ASCII\n");
    file << "DATASET UNSTRUCTURED_GRID\n";

    if (!Binary) {
        file << std::fixed << std::setprecision(15);
    }

    // Write points
    file << "POINTS " << num_elements * 8 << " double\n";
    for(const auto& r_element : rBackgroundGrid.Elements()){
        const auto& [lower_point, upper_point] = r_element.GetBoundsXYZ();
        auto vertices = GetHexahedronVertices(lower_point, upper_point);
        for (const auto& v : vertices) {
            if( Binary ){
                double x = v[0], y = v[1], z = v[2];
                SwapEnd(x); SwapEnd(y); SwapEnd(z);
                file.write(reinterpret_cast<char*>(&x), sizeof(double));
                file.write(reinterpret_cast<char*>(&y), sizeof(double));
                file.write(reinterpret_cast<char*>(&z), sizeof(double));
            } else {
                file << v[0] << ' ' << v[1] << ' ' << v[2] << '\n';
            }
        }
    }

    // Write cells
    file << "CELLS " << num_elements << " " << num_elements*9 << '\n';
    for(IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            std::uint32_t k = 8;
            WriteBinary(file, k);
            for( std::uint32_t j = 0; j < 8; ++j){
                k = 8*static_cast<std::uint32_t>(i)+j;
                WriteBinary(file, k);
            }
        }
        else {
            file << 8;
            for (IndexType j = 0; j < 8; ++j) {
                file << ' ' << (8 * i + j);
            }
            file << '\n';
        }
    }

    // Write cell type
    file << "CELL_TYPES " << num_elements << '\n';
    for(IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            std::uint32_t k = 12;
            WriteBinary(file, k);
        }
        else {
            file << 12 << '\n';
        }
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write elements to file: " << rFilename << ".\n";
}

template<typename TElementType>
void IO::WritePointsToVTK(const BackgroundGrid<TElementType>& rBackgroundGrid,
                            const std::string& rFilename,
                            bool Binary) {
    // Open file
    std::ofstream file(rFilename, Binary ? (std::ios::out | std::ios::binary) : std::ios::out);
    QuESo_ERROR_IF(!file) << "Could not create/open file: " << rFilename << ".\n";

    const IndexType num_points = std::accumulate(
        rBackgroundGrid.ElementsBegin(), rBackgroundGrid.ElementsEnd(), IndexType{0}, [](IndexType Acc, const auto& rElement) {
            return Acc + rElement.GetIntegrationPoints().size(); } );
    const IndexType num_elements = num_points;

    // Header
    file << "# vtk DataFile Version 4.1\n";
    file << "vtk output\n";
    file << (Binary ? "BINARY\n" : "ASCII\n");
    file << "DATASET UNSTRUCTURED_GRID\n";

    if (!Binary) {
        file << std::fixed << std::setprecision(15);
    }

    // Write points
    file << "POINTS " << num_points << " double\n";
    for(const auto& r_element : rBackgroundGrid.Elements()){
        const auto& r_points = r_element.GetIntegrationPoints();
        for( const auto& r_point : r_points ){
            auto point_global = r_element.PointFromParamToGlobal(r_point.data());
            if( Binary ){
                WriteBinary(file, point_global[0]);
                WriteBinary(file, point_global[1]);
                WriteBinary(file, point_global[2]);
            }
            else {
                file << point_global[0] << ' ' << point_global[1] << ' ' << point_global[2] << '\n';
            }
        }

    }

    // Write Cells
    file << "CELLS " << num_elements << " " << num_elements*2 << '\n';
    for(IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            std::uint32_t k = 1;
            WriteBinary(file, k);
            k = static_cast<std::uint32_t>(i);
            WriteBinary(file, k);
        } else {
            file << 1 << ' ' << i << '\n';
        }
    }

    // Write cell types
    file << "CELL_TYPES " << num_elements << '\n';
    for(IndexType i = 0; i < num_elements; ++i){
        if( Binary ){
            std::uint32_t k = 1;
            WriteBinary(file, k);
        }
        else {
            file << 1 << '\n';
        }
    }

    // Write weights
    file << "POINT_DATA " << num_points << '\n';
    file << "SCALARS Weights double 1\n";
    file << "LOOKUP_TABLE default\n";
    for(const auto& r_element : rBackgroundGrid.Elements()){
        const auto& points = r_element.GetIntegrationPoints();
        for(const auto& point : points ){
            if( Binary ){
                double weight = point.Weight();
                WriteBinary(file, weight);
            }
            else {
                file << point.Weight() << '\n';
            }
        }
    }

    file.flush();
    QuESo_ERROR_IF(!file.good()) << "Failed to write points to file: " << rFilename << ".\n";
}

} // End namespace queso